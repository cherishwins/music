/**
 * Minter Credit Score (MCS) Calculator
 * The Equifax of Memecoins - proprietary scoring algorithm
 *
 * Score Components:
 * - Minter History: 35% - Track record of previous launches
 * - Token Safety: 40% - Contract analysis, honeypot detection
 * - Behavior Signals: 25% - Trading patterns, social verification
 *
 * TON Labels Integration:
 * - 2,958 labeled addresses from ton-studio/ton-labels
 * - Categories: CEX, DEX, validator, bridge, scammer, etc.
 * - Known entities get boosted/penalized scores based on category
 */

import { dyorApi, type DYORTrustScore, type DYORTokenInfo, type DYORPoolInfo } from "./dyor-api";
import { tonApi, type MinterHistory, type TonWalletInfo } from "./tonapi";

// Import FULL ton-labels dataset (2,958 addresses)
// Generated by scripts/build-ton-labels.py
import tonLabelsData from "../../data/ton-labels-compiled.json";

// ============================================
// TON Labels Integration (2,958 Labeled Addresses)
// ============================================

interface TonLabel {
  category: string;
  subcategory: string;
  label: string;
  description: string;
  organization: string;
  website: string;
  comment: string;
  tags: string[];
  source: string;
  submittedBy: string;
}

interface TonLabelsDB {
  version: string;
  generated: string;
  source: string;
  stats: Record<string, number>;
  total: number;
  addresses: Record<string, TonLabel>;
}

// Type the imported data
const tonLabels = tonLabelsData as TonLabelsDB;
const labeledAddresses = tonLabels.addresses;

// Category trust scores (0-100, higher = more trusted)
const CATEGORY_TRUST_SCORES: Record<string, number> = {
  // Highly trusted infrastructure (A+ grade = 95+)
  cex: 95,           // Centralized exchanges - regulated, custodial
  validator: 95,     // Network validators - core infrastructure
  bridge: 90,        // Cross-chain bridges - audited protocols

  // Trusted DeFi (A grade = 85-94)
  dex: 90,           // Decentralized exchanges
  liquid_staking: 88, // Staking protocols
  lending: 85,       // Lending protocols
  yield_aggregator: 82, // Yield farms

  // Neutral/Known entities (B grade = 70-84)
  infrastructure: 80, // General infra
  wallet: 75,        // Known wallets
  fund: 75,          // Investment funds
  merchant: 70,      // Merchants accepting TON
  cdp: 70,           // CDP protocols

  // Caution (C grade = 50-69)
  gaming: 60,        // Gaming - can be legit or risky
  tradingbot: 55,    // Bots - often used for manipulation
  ads: 50,           // Advertising - mixed bag
  other: 50,         // Uncategorized

  // High risk (D grade = 30-49)
  "scripted-activity": 35, // Scripted/bot activity

  // Danger (F grade = 0-29)
  scammer: 0,        // Confirmed scammers
};

/**
 * Check if an address is labeled in ton-labels
 */
export function checkTonLabel(address: string): TonLabel | null {
  return labeledAddresses[address] || null;
}

/**
 * Check if address is a known scammer
 */
export function isKnownScammer(address: string): boolean {
  const label = labeledAddresses[address];
  return label?.category === "scammer";
}

/**
 * Get labeled address count for stats
 */
export function getLabeledAddressCount(): number {
  return tonLabels.total;
}

/**
 * Get scammer count for stats
 */
export function getScammerCount(): number {
  return tonLabels.stats.scammer || 0;
}

/**
 * Get category stats
 */
export function getCategoryStats(): Record<string, number> {
  return tonLabels.stats;
}

/**
 * Get all labels for an address with category-based trust assessment
 */
export function getAddressLabels(address: string): {
  isLabeled: boolean;
  isScammer: boolean;
  isCEX: boolean;
  isDEX: boolean;
  isValidator: boolean;
  isBot: boolean;
  isTrustedEntity: boolean;
  category: string | null;
  trustScore: number;
  label: TonLabel | null;
  riskFlags: string[];
  trustFlags: string[];
} {
  const label = labeledAddresses[address];

  const riskFlags: string[] = [];
  const trustFlags: string[] = [];

  if (!label) {
    return {
      isLabeled: false,
      isScammer: false,
      isCEX: false,
      isDEX: false,
      isValidator: false,
      isBot: false,
      isTrustedEntity: false,
      category: null,
      trustScore: 50, // Neutral for unknown
      label: null,
      riskFlags,
      trustFlags,
    };
  }

  const category = label.category;
  const trustScore = CATEGORY_TRUST_SCORES[category] ?? 50;

  // Categorize by type
  const isScammer = category === "scammer";
  const isCEX = category === "cex";
  const isDEX = category === "dex";
  const isValidator = category === "validator";
  const isBot = category === "scripted-activity" || category === "tradingbot";
  const isTrustedEntity = trustScore >= 80;

  // Generate flags based on category
  if (isScammer) {
    riskFlags.push(`üö® KNOWN SCAMMER: ${label.label} - ${label.comment || label.description || "Flagged by TON community"}`);
    if (label.subcategory === "drainer") {
      riskFlags.push("‚ö†Ô∏è DRAINER CONTRACT: Will drain your wallet!");
    }
  } else if (isCEX) {
    trustFlags.push(`‚úÖ VERIFIED CEX: ${label.organization || label.label}${label.website ? ` (${label.website})` : ""}`);
  } else if (isDEX) {
    trustFlags.push(`‚úÖ VERIFIED DEX: ${label.organization || label.label}${label.website ? ` (${label.website})` : ""}`);
  } else if (isValidator) {
    trustFlags.push(`‚úÖ NETWORK VALIDATOR: ${label.label} - Core TON infrastructure`);
  } else if (category === "bridge") {
    trustFlags.push(`‚úÖ BRIDGE PROTOCOL: ${label.label}${label.website ? ` (${label.website})` : ""}`);
  } else if (category === "liquid_staking") {
    trustFlags.push(`‚úÖ STAKING PROTOCOL: ${label.label} - Liquid staking service`);
  } else if (category === "lending") {
    trustFlags.push(`‚úÖ LENDING PROTOCOL: ${label.label}`);
  } else if (category === "infrastructure") {
    trustFlags.push(`‚ÑπÔ∏è INFRASTRUCTURE: ${label.label} - ${label.description || "TON ecosystem service"}`);
  } else if (category === "fund") {
    trustFlags.push(`‚ÑπÔ∏è INVESTMENT FUND: ${label.organization || label.label}`);
  } else if (category === "merchant") {
    trustFlags.push(`‚ÑπÔ∏è MERCHANT: ${label.label} - Accepts TON payments`);
  } else if (isBot) {
    riskFlags.push(`‚ö†Ô∏è BOT/SCRIPT: ${label.label} - Automated activity detected`);
  } else if (category === "gaming") {
    trustFlags.push(`‚ÑπÔ∏è GAMING: ${label.label}${label.website ? ` (${label.website})` : ""}`);
  } else {
    // Other categories
    if (trustScore >= 70) {
      trustFlags.push(`‚ÑπÔ∏è KNOWN ENTITY: ${label.label} (${category})`);
    } else if (trustScore < 50) {
      riskFlags.push(`‚ö†Ô∏è CAUTION: ${label.label} (${category})`);
    }
  }

  // Add tag-based flags
  if (label.tags?.includes("suspicious")) {
    riskFlags.push("‚ö†Ô∏è SUSPICIOUS: Flagged for suspicious activity");
  }
  if (label.tags?.includes("has-custodial-wallets")) {
    trustFlags.push("‚ÑπÔ∏è Has custodial wallet services");
  }

  return {
    isLabeled: true,
    isScammer,
    isCEX,
    isDEX,
    isValidator,
    isBot,
    isTrustedEntity,
    category,
    trustScore,
    label,
    riskFlags,
    trustFlags,
  };
}

// Score thresholds and grades
const GRADES = {
  "A+": { min: 900, color: "#22C55E", description: "Exceptional - Highly Trusted" },
  A: { min: 800, color: "#4ADE80", description: "Excellent - Very Reliable" },
  B: { min: 700, color: "#84CC16", description: "Good - Generally Safe" },
  C: { min: 600, color: "#FACC15", description: "Fair - Exercise Caution" },
  D: { min: 500, color: "#F97316", description: "Poor - High Risk" },
  F: { min: 0, color: "#EF4444", description: "Fail - Extreme Risk / Likely Rug" },
} as const;

type Grade = keyof typeof GRADES;

export interface MinterCreditScore {
  score: number; // 0-1000
  grade: Grade;
  gradeInfo: (typeof GRADES)[Grade];
  riskLevel: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
  components: {
    history: {
      score: number;
      weight: 0.35;
      details: {
        totalLaunches: number;
        survivalRate: number;
        rugRate: number;
        averageLifespan: number;
      };
    };
    safety: {
      score: number;
      weight: 0.4;
      details: {
        mintAuthority: boolean;
        freezeAuthority: boolean;
        liquidityLocked: boolean;
        topHolderConcentration: number;
        honeypotRisk: boolean;
        contractVerified: boolean;
      };
    };
    behavior: {
      score: number;
      weight: 0.25;
      details: {
        walletAge: number;
        transactionCount: number;
        diversification: number;
        socialVerified: boolean;
      };
    };
  };
  recommendation: string;
  warnings: string[];
  analyzedAt: string;
  // New: Entity info from ton-labels (2,958 labeled addresses)
  entityInfo?: {
    category: string | null;
    label: string | undefined;
    organization: string | undefined;
    website: string | undefined;
    trustFlags: string[];
  };
}

export interface TokenAnalysis {
  tokenAddress: string;
  minterAddress: string;
  tokenInfo: DYORTokenInfo | null;
  trustScore: DYORTrustScore | null;
  pools: DYORPoolInfo[];
  minterScore: MinterCreditScore;
}

/**
 * Calculate the Minter Credit Score for a wallet
 */
export async function calculateMinterScore(
  walletAddress: string,
  tokenAddress?: string
): Promise<MinterCreditScore> {
  // Check ton-labels for known entities FIRST
  const addressLabels = getAddressLabels(walletAddress);

  // Fetch all required data in parallel
  const [minterHistoryRes, walletInfoRes, trustScoreRes] = await Promise.all([
    tonApi.getMinterHistory(walletAddress),
    tonApi.getWalletInfo(walletAddress),
    tokenAddress
      ? dyorApi.getTrustScore(tokenAddress)
      : Promise.resolve({ success: false, data: undefined }),
  ]);

  const minterHistory = minterHistoryRes.data;
  const walletInfo = walletInfoRes.data;
  const trustScore = trustScoreRes.success ? trustScoreRes.data : undefined;

  // Calculate component scores
  const historyScore = calculateHistoryScore(minterHistory);
  const safetyScore = calculateSafetyScore(trustScore);
  const behaviorScore = calculateBehaviorScore(walletInfo, minterHistory);

  // Weighted combination (scale to 0-100 first)
  let rawScore =
    historyScore.score * 0.35 + safetyScore.score * 0.4 + behaviorScore.score * 0.25;

  // Apply ton-labels category-based scoring
  if (addressLabels.isLabeled) {
    if (addressLabels.isScammer) {
      // CRITICAL: Known scammer = instant 0
      rawScore = 0;
    } else if (addressLabels.isTrustedEntity) {
      // Trusted entities (CEX, DEX, validator, bridge, etc) get boosted
      // Use weighted average: 60% ton-labels trust, 40% calculated score
      rawScore = addressLabels.trustScore * 0.6 + rawScore * 0.4;
    } else if (addressLabels.isBot) {
      // Bots/scripts get capped at low score
      rawScore = Math.min(rawScore, addressLabels.trustScore);
    } else {
      // Other labeled entities: blend scores
      rawScore = addressLabels.trustScore * 0.3 + rawScore * 0.7;
    }
  }

  const finalScore = Math.round(rawScore * 10);

  // Determine grade
  const grade = getGrade(finalScore);
  const riskLevel = getRiskLevel(finalScore);

  // Generate warnings (include ton-labels flags)
  const warnings = generateWarnings(historyScore, safetyScore, behaviorScore);

  // Prepend risk flags (most important)
  if (addressLabels.riskFlags.length > 0) {
    warnings.unshift(...addressLabels.riskFlags);
  }

  // Generate recommendation based on entity type
  let recommendation: string;
  if (addressLabels.isScammer) {
    recommendation = "üö® CONFIRMED SCAMMER - This address is in the TON community scammer database. DO NOT INTERACT.";
  } else if (addressLabels.isCEX) {
    recommendation = `‚úÖ VERIFIED EXCHANGE - ${addressLabels.label?.organization || addressLabels.label?.label} is a known centralized exchange.`;
  } else if (addressLabels.isDEX) {
    recommendation = `‚úÖ VERIFIED DEX - ${addressLabels.label?.label} is a known decentralized exchange protocol.`;
  } else if (addressLabels.isValidator) {
    recommendation = `‚úÖ NETWORK VALIDATOR - This is core TON blockchain infrastructure.`;
  } else if (addressLabels.isTrustedEntity) {
    recommendation = `‚úÖ VERIFIED ENTITY - ${addressLabels.label?.label} is a known ${addressLabels.category} in the TON ecosystem.`;
  } else {
    recommendation = generateRecommendation(finalScore, warnings);
  }

  return {
    score: finalScore,
    grade,
    gradeInfo: GRADES[grade],
    riskLevel: addressLabels.isScammer ? "CRITICAL" : riskLevel,
    components: {
      history: {
        score: historyScore.score,
        weight: 0.35,
        details: historyScore.details,
      },
      safety: {
        score: safetyScore.score,
        weight: 0.4,
        details: safetyScore.details,
      },
      behavior: {
        score: behaviorScore.score,
        weight: 0.25,
        details: behaviorScore.details,
      },
    },
    recommendation,
    warnings,
    analyzedAt: new Date().toISOString(),
    // Add new fields for UI
    entityInfo: addressLabels.isLabeled ? {
      category: addressLabels.category,
      label: addressLabels.label?.label,
      organization: addressLabels.label?.organization,
      website: addressLabels.label?.website,
      trustFlags: addressLabels.trustFlags,
    } : undefined,
  };
}

/**
 * Full token analysis including minter score
 */
export async function analyzeToken(tokenAddress: string): Promise<TokenAnalysis> {
  // Get token info first to find the deployer
  const tokenInfoRes = await dyorApi.getTokenInfo(tokenAddress);
  const tokenInfo = tokenInfoRes.data || null;

  // Use deployer address or fall back to a placeholder
  const minterAddress = tokenInfo?.deployer || "unknown";

  // Fetch remaining data
  const [trustScoreRes, poolsRes, minterScore] = await Promise.all([
    dyorApi.getTrustScore(tokenAddress),
    dyorApi.getPoolInfo(tokenAddress),
    calculateMinterScore(minterAddress, tokenAddress),
  ]);

  return {
    tokenAddress,
    minterAddress,
    tokenInfo,
    trustScore: trustScoreRes.data || null,
    pools: poolsRes.data || [],
    minterScore,
  };
}

// === Component Score Calculators ===

function calculateHistoryScore(history?: MinterHistory): {
  score: number;
  details: MinterCreditScore["components"]["history"]["details"];
} {
  if (!history) {
    // New minter - neutral score
    return {
      score: 50,
      details: {
        totalLaunches: 0,
        survivalRate: 100,
        rugRate: 0,
        averageLifespan: 0,
      },
    };
  }

  let score = 50; // Base score

  // Survival rate (0-30 points)
  score += (history.survivalRate / 100) * 30;

  // Rug rate penalty (-50 to 0 points)
  score -= (history.rugRate / 100) * 50;

  // Experience bonus (0-10 points, diminishing returns)
  const experienceBonus = Math.min(10, Math.log10(history.totalTokensLaunched + 1) * 5);
  score += experienceBonus;

  // Longevity bonus (0-10 points)
  if (history.averageLifespan > 90) score += 10;
  else if (history.averageLifespan > 30) score += 5;
  else if (history.averageLifespan > 7) score += 2;

  return {
    score: Math.max(0, Math.min(100, score)),
    details: {
      totalLaunches: history.totalTokensLaunched,
      survivalRate: Math.round(history.survivalRate),
      rugRate: Math.round(history.rugRate),
      averageLifespan: history.averageLifespan,
    },
  };
}

function calculateSafetyScore(trustScore?: DYORTrustScore): {
  score: number;
  details: MinterCreditScore["components"]["safety"]["details"];
} {
  if (!trustScore) {
    // No token to analyze - return neutral
    return {
      score: 50,
      details: {
        mintAuthority: false,
        freezeAuthority: false,
        liquidityLocked: false,
        topHolderConcentration: 0,
        honeypotRisk: false,
        contractVerified: false,
      },
    };
  }

  let score = trustScore.score; // Start with DYOR's score as base

  // Apply our own adjustments
  const factors = trustScore.factors;

  // Critical penalties
  if (factors.mintAuthority) score -= 20;
  if (factors.freezeAuthority) score -= 15;
  if (factors.honeypotRisk) score -= 30;
  if (!factors.liquidityLocked) score -= 15;

  // Concentration penalty (if >50% held by top 10)
  if (factors.topHolderConcentration > 50) {
    score -= Math.min(20, (factors.topHolderConcentration - 50) * 0.5);
  }

  // Verification bonus
  if (factors.contractVerified) score += 10;

  return {
    score: Math.max(0, Math.min(100, score)),
    details: {
      mintAuthority: factors.mintAuthority,
      freezeAuthority: factors.freezeAuthority,
      liquidityLocked: factors.liquidityLocked,
      topHolderConcentration: Math.round(factors.topHolderConcentration),
      honeypotRisk: factors.honeypotRisk,
      contractVerified: factors.contractVerified,
    },
  };
}

function calculateBehaviorScore(
  walletInfo?: TonWalletInfo,
  minterHistory?: MinterHistory
): {
  score: number;
  details: MinterCreditScore["components"]["behavior"]["details"];
} {
  let score = 50; // Base score

  // Wallet age bonus (check last activity)
  let walletAge = 0;
  if (walletInfo?.lastActivity) {
    const lastActive = new Date(walletInfo.lastActivity);
    walletAge = Math.floor((Date.now() - lastActive.getTime()) / (1000 * 60 * 60 * 24));
    // Older wallets get bonus (max 20 points for 365+ days)
    score += Math.min(20, walletAge / 18);
  }

  // Transaction diversity (based on minter history variety)
  let diversification = 0;
  if (minterHistory && minterHistory.totalTokensLaunched > 0) {
    diversification = Math.min(100, minterHistory.totalTokensLaunched * 10);
    score += diversification * 0.15;
  }

  // Activity level (placeholder for transaction count analysis)
  const transactionCount = minterHistory?.launches?.length || 0;
  score += Math.min(15, transactionCount * 2);

  return {
    score: Math.max(0, Math.min(100, score)),
    details: {
      walletAge,
      transactionCount,
      diversification: Math.round(diversification),
      socialVerified: false, // Future: Telegram/social verification
    },
  };
}

// === Helper Functions ===

function getGrade(score: number): Grade {
  if (score >= 900) return "A+";
  if (score >= 800) return "A";
  if (score >= 700) return "B";
  if (score >= 600) return "C";
  if (score >= 500) return "D";
  return "F";
}

function getRiskLevel(score: number): MinterCreditScore["riskLevel"] {
  if (score >= 700) return "LOW";
  if (score >= 500) return "MEDIUM";
  if (score >= 300) return "HIGH";
  return "CRITICAL";
}

function generateWarnings(
  history: ReturnType<typeof calculateHistoryScore>,
  safety: ReturnType<typeof calculateSafetyScore>,
  behavior: ReturnType<typeof calculateBehaviorScore>
): string[] {
  const warnings: string[] = [];

  // History warnings
  if (history.details.rugRate > 20) {
    warnings.push(`High rug rate: ${history.details.rugRate}% of previous launches failed`);
  }
  if (history.details.totalLaunches === 0) {
    warnings.push("New minter: No track record available");
  }
  if (history.details.averageLifespan < 7 && history.details.totalLaunches > 0) {
    warnings.push("Short-lived tokens: Average lifespan under 7 days");
  }

  // Safety warnings
  if (safety.details.mintAuthority) {
    warnings.push("CRITICAL: Mint authority enabled - can create unlimited tokens");
  }
  if (safety.details.freezeAuthority) {
    warnings.push("WARNING: Freeze authority enabled - can freeze your wallet");
  }
  if (safety.details.honeypotRisk) {
    warnings.push("CRITICAL: Honeypot detected - you may not be able to sell");
  }
  if (!safety.details.liquidityLocked) {
    warnings.push("WARNING: Liquidity not locked - rug pull risk");
  }
  if (safety.details.topHolderConcentration > 50) {
    warnings.push(
      `High concentration: Top holders control ${safety.details.topHolderConcentration}%`
    );
  }

  // Behavior warnings
  if (behavior.details.walletAge < 7) {
    warnings.push("New wallet: Less than 7 days old");
  }

  return warnings;
}

function generateRecommendation(score: number, warnings: string[]): string {
  const criticalWarnings = warnings.filter((w) => w.startsWith("CRITICAL")).length;

  if (criticalWarnings > 0) {
    return "DO NOT INVEST - Critical security issues detected. High probability of rug pull.";
  }

  if (score >= 800) {
    return "Generally safe to invest. This minter has a strong track record and the token passes security checks.";
  }

  if (score >= 600) {
    return "Proceed with caution. Some risk factors present. Only invest what you can afford to lose.";
  }

  if (score >= 400) {
    return "High risk investment. Multiple warning signs detected. Consider this a gamble, not an investment.";
  }

  return "Extreme risk. This has all the hallmarks of a rug pull. Avoid unless you're okay losing 100%.";
}

// Export types
export type { Grade };
